{"version":3,"sources":["core/books.ts","core/optimize.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["bookDataTitles","list","i","data","length","push","title","titlesToBoolean","ob","forEach","v","k","bookIdByTitle","id","resourcePrefixes","optimize","state","a","async","allbooks","Object","keys","bookpkg","filter","book","console","log","booksDone","booksOpt","includes","bookCountTotalsPreOpt","Map","bookCountArticleTotalsPreOpt","bklist","bk","bkid","books","res","dbkey","dbsetup","getItem","undefined","rescount","total","grandTotalWordCount","has","set","get","doneGrandTotal","doneArticleMap","dam","detail_article_map","articles","j","articleCount","values","c","resourceTotal","round","optBooks","optCounts","n","newBooks","newCounts","optArticleMap","optBookTotal","roundWinnerBook","roundWinnerCount","Typography","map","t","key","useStyles","makeStyles","theme","createStyles","root","width","formControl","margin","spacing","button","marginRight","instructions","marginTop","marginBottom","GreenCheckbox","withStyles","color","green","checked","props","Checkbox","joinBookIds","x","y","join","Boolean","window","location","hostname","match","ReactDOM","render","name","classes","React","useState","activeStep","setActiveStep","Set","skipped","setSkipped","steps","isStepSkipped","step","handleReset","clearFlag","clearF","setClearF","setState","handleChange","event","b","target","handleFinishedChange","_opt","setOpt","useEffect","opt","result","message","fetchData","className","Stepper","label","index","stepProps","labelProps","completed","Step","StepLabel","Button","onClick","variant","FormGroup","row","FormControlLabel","control","Switch","onChange","value","getStepContent","FormControl","required","component","FormLabel","FormHelperText","disabled","prevActiveStep","newSkipped","delete","Paper","bookId","chapter","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.243efd85.chunk.js","sourcesContent":["import data from './books.json';\r\nimport * as opt from './optimize'\r\n\r\nexport interface bookDataIF {\r\n  \"id\": string;\r\n  \"title\": string;\r\n  \"usfm\": string;\r\n  \"testament\": string;\r\n  \"verseCount\": number;\r\n  \"chapters\": number[];\r\n}\r\n\r\nexport const chaptersInBook = (bookId: string) => {\r\n    let chapters: number[];\r\n    chapters = bookData(bookId).chapters;\r\n    if ( chapters === undefined ) {\r\n      throw new Error(\"Error: chaptersInBook(): Invalid bookId\");\r\n    }\r\n    return chapters;\r\n};\r\n\r\nexport const versesInChapter = (bookId: string, chapter: number) => {\r\n  const verses = chaptersInBook(bookId)[chapter - 1];\r\n  return verses;\r\n};\r\n\r\nexport const bookData = (bookId: string) => {\r\n  const _bookData: bookDataIF = data.filter(row => row.id === bookId)[0];\r\n  return _bookData;\r\n};\r\n\r\nexport const testament = (bookId: string) => {\r\n  const _testament = bookData(bookId).testament;\r\n  return _testament;\r\n};\r\n\r\nexport const bookDataTitles = () => {\r\n  let list: string[] = [];\r\n  for (let i=0; i < data.length; i++) {\r\n      list.push( data[i].title )\r\n  }\r\n  return list;\r\n}\r\n\r\nexport const titlesToBoolean = () => {\r\n  let ob: opt.bpStateIF = {};\r\n  let list = bookDataTitles();\r\n  list.forEach((v,k) => {ob[v]= [false,false]});\r\n  return ob;\r\n}\r\n\r\nexport const bookIdByTitle = (title: string) => {\r\n  for (let i=0; i < data.length; i++) {\r\n    if ( data[i].title === title ) {\r\n      return data[i].id;\r\n    }\r\n  }\r\n  return \"\";\r\n}","import React from 'react';\r\nimport Typography from '@material-ui/core/Typography';\r\nimport * as dbsetup from 'book-package-rcl';\r\nimport * as books from './books';\r\n\r\nexport interface bpStateIF { [x: string]: boolean[]; };\r\n  \r\nconst resourcePrefixes = ['uta-', 'utw-', 'ult-','ust-', 'utq-', 'utn-']\r\n\r\nexport async function optimize(state: bpStateIF ) {\r\n    // extract the books in the package\r\n    const allbooks = Object.keys(state);\r\n    // extract the book package\r\n    const bookpkg    = allbooks.filter( function(book) { return state[book][0] } );\r\n    console.log(\"bookpkg:\",bookpkg);\r\n    // extract the books that are done/completed first (if any)\r\n    const booksDone  = bookpkg.filter( function(book) { return state[book][1] } );\r\n    console.log(\"booksDone:\",booksDone);\r\n    // books to be optimized\r\n    const booksOpt   = bookpkg.filter( function(book) { return !booksDone.includes(book) } );\r\n    console.log(\"booksOpt:\",booksOpt);\r\n\r\n    // count words in each book for pre-optimization summary\r\n    let bookCountTotalsPreOpt = new Map<string,number>();\r\n    let bookCountArticleTotalsPreOpt = new Map<string,number>();\r\n    let bklist: string[] = [];\r\n    for (let bk of bookpkg) {\r\n        let bkid = books.bookIdByTitle(bk);\r\n        bklist.push(bkid);\r\n        for (let res of resourcePrefixes) {\r\n            let dbkey = res+bkid;\r\n            let data = await dbsetup.bpstore.getItem(dbkey);\r\n            let rescount = data.total;\r\n            if ( rescount === undefined ) {\r\n                rescount = data.grandTotalWordCount\r\n                // add to article count (deduped)\r\n                if ( bookCountArticleTotalsPreOpt.has(bkid) ) {\r\n                    bookCountArticleTotalsPreOpt.set(bkid, bookCountArticleTotalsPreOpt.get(bkid) + rescount);\r\n                } else {\r\n                    bookCountArticleTotalsPreOpt.set(bkid,rescount)\r\n                }\r\n            };\r\n            if ( bookCountTotalsPreOpt.has(bkid) ) {\r\n                bookCountTotalsPreOpt.set(bkid, bookCountTotalsPreOpt.get(bkid) + rescount);\r\n            } else {\r\n                bookCountTotalsPreOpt.set(bkid,rescount);\r\n            }\r\n        }    \r\n    }\r\n\r\n    /*\r\n        For the books marked as done, compute their word count contribution by:\r\n        a. create a deduped list of all articles (UTA and UTW) with their counts\r\n        b. compute the grand total of the articles\r\n        c. Add to that the total word counts for UTQ, UTN, ULT, and UST\r\n        d. This sum total will be the starting point for the book package flow.\r\n    */\r\n    let doneGrandTotal = 0;\r\n    let doneArticleMap = new Map<string,number>();\r\n    for (let i=0; i < booksDone.length; i++) {\r\n        // get the UTA articles and their counts\r\n        let bkid = books.bookIdByTitle(booksDone[i]);\r\n        let dbkey = \"uta-\"+bkid;\r\n        let data = await dbsetup.bpstore.getItem(dbkey);\r\n        let dam = data.detail_article_map;\r\n        let articles = Object.keys(dam);\r\n        for (let j=0; j< articles.length; j++) {\r\n            let articleCount = dam[articles[j]].total;\r\n            // now add to map. dups expected\r\n            if ( ! doneArticleMap.has(articles[j])) {\r\n                doneArticleMap.set(articles[j], articleCount);\r\n                //console.log(articles[j], articleCount);\r\n            }\r\n        }\r\n\r\n        // get the UTW articles and their counts\r\n        dbkey = \"utw-\"+bkid;\r\n        data = await dbsetup.bpstore.getItem(dbkey);\r\n        dam = data.detail_article_map;\r\n        articles = Object.keys(dam);\r\n        for (let j=0; j< articles.length; j++) {\r\n            let articleCount = dam[articles[j]].total;\r\n            // now add to map. dups expected\r\n            if ( ! doneArticleMap.has(articles[j])) {\r\n                doneArticleMap.set(articles[j], articleCount);\r\n                //console.log(articles[j], articleCount);\r\n            }\r\n        }\r\n    }\r\n\r\n    // add up the article contributions\r\n    for ( let c of doneArticleMap.values() ) {\r\n        doneGrandTotal = doneGrandTotal + c;\r\n    }\r\n    console.log(\"done article total is:\", doneGrandTotal);\r\n\r\n    // now add in the UTQ, UTN, ULT, UST for each completed book\r\n    for (let i=0; i < booksDone.length; i++) {\r\n        // get the UTA articles and their counts\r\n        let bkid = books.bookIdByTitle(booksDone[i]);\r\n        let dbkey = \"utq-\"+bkid;\r\n        let data  = await dbsetup.bpstore.getItem(dbkey);\r\n        let resourceTotal = data.total;\r\n        doneGrandTotal = doneGrandTotal + resourceTotal;\r\n        dbkey = \"utn-\"+bkid;\r\n        data  = await dbsetup.bpstore.getItem(dbkey);\r\n        resourceTotal = data.total;\r\n        doneGrandTotal = doneGrandTotal + resourceTotal;\r\n        dbkey = \"ult-\"+bkid;\r\n        data  = await dbsetup.bpstore.getItem(dbkey);\r\n        resourceTotal = data.total;\r\n        doneGrandTotal = doneGrandTotal + resourceTotal;\r\n        dbkey = \"ust-\"+bkid;\r\n        data  = await dbsetup.bpstore.getItem(dbkey);\r\n        resourceTotal = data.total;\r\n        doneGrandTotal = doneGrandTotal + resourceTotal;\r\n    }\r\n    console.log(\"Done grand total is:\", doneGrandTotal);\r\n    /*\r\n        The above marks the end of the computation of the books \r\n        marked as done.\r\n    */\r\n   \r\n\r\n    /*\r\n        This is the loop that computes the optimized path.\r\n        Given that there are n books to optimize, then the \r\n        loop only needs to be done n-1 times. At that point, \r\n        only one book is left and it will be the last one.\r\n\r\n        The inner loop will loop thru all the remaining \r\n        books to determine which should be next. This is done\r\n        by computing word counts of all the resources\r\n        associated to the book, but excluding any articles \r\n        (i.e., UTA and UTW) that have already been done.\r\n\r\n        The inner loop will be executed one less each time,\r\n        since the winning book in each round will be removed\r\n        from the array of books to be optimized. In the last\r\n        round, there will be two books left to do.\r\n\r\n    */\r\n    let round:number = 0;\r\n    let optBooks: string[] = [];\r\n    let optCounts: number[] = [];\r\n    for (let n=0; n < booksOpt.length; n++ ) {\r\n        round++;\r\n        console.log(\"Begin round:\",round);\r\n        let newBooks: string[] = [];\r\n        let newCounts: number[] = [];\r\n        for (let i=0; i < booksOpt.length; i++) {\r\n            // skip winners from prior rounds\r\n            if ( optBooks.includes(booksOpt[i]) ) {\r\n                continue;\r\n            }\r\n            // The book for this round:\r\n            newBooks.push(booksOpt[i]);\r\n            // get the UTA articles and their counts\r\n            let bkid = books.bookIdByTitle(booksOpt[i]);\r\n            let dbkey = \"uta-\"+bkid;\r\n            let data = await dbsetup.bpstore.getItem(dbkey);\r\n            let dam = data.detail_article_map;\r\n            let articles = Object.keys(dam);\r\n\r\n            // dedup the articles for this book\r\n            // using the article map below\r\n            let optArticleMap = new Map<string,number>();\r\n\r\n            for (let j=0; j< articles.length; j++) {\r\n                // first check to see if this article is in the done list\r\n                // if so skip it\r\n                if ( doneArticleMap.has(articles[j]) ) { continue;}\r\n                let articleCount = dam[articles[j]].total;\r\n                // now add to map. dups expected\r\n                optArticleMap.set(articles[j], articleCount);\r\n                //console.log(articles[j], articleCount);\r\n            }\r\n\r\n            // get the UTW articles and their counts\r\n            dbkey = \"utw-\"+bkid;\r\n            data = await dbsetup.bpstore.getItem(dbkey);\r\n            dam = data.detail_article_map;\r\n            articles = Object.keys(dam);\r\n\r\n            for (let j=0; j< articles.length; j++) {\r\n                // first check to see if this article is in the done list\r\n                // if so skip it\r\n                if ( doneArticleMap.has(articles[j]) ) { continue;}\r\n                let articleCount = dam[articles[j]].total;\r\n                // now add to map\r\n                optArticleMap.set(articles[j], articleCount);\r\n                //console.log(articles[j], articleCount);\r\n            }\r\n\r\n            // add up the article contributions for this book\r\n            let optBookTotal: number = 0;\r\n            for ( let c of optArticleMap.values() ) {\r\n                optBookTotal = optBookTotal + c;\r\n            }\r\n            console.log(\"book article total is:\", booksOpt[i],optBookTotal );\r\n\r\n            // now add in the UTQ, UTN, ULT, UST for each completed book\r\n            dbkey = \"utq-\"+bkid;\r\n            data  = await dbsetup.bpstore.getItem(dbkey);\r\n            optBookTotal = optBookTotal + data.total;\r\n            dbkey = \"utn-\"+bkid;\r\n            data  = await dbsetup.bpstore.getItem(dbkey);\r\n            optBookTotal = optBookTotal + data.total;\r\n            dbkey = \"ult-\"+bkid;\r\n            data  = await dbsetup.bpstore.getItem(dbkey);\r\n            optBookTotal = optBookTotal + data.total;\r\n            dbkey = \"ust-\"+bkid;\r\n            data  = await dbsetup.bpstore.getItem(dbkey);\r\n            optBookTotal = optBookTotal + data.total;\r\n            newCounts.push(optBookTotal);\r\n            console.log(\"Book grand total is:\", booksOpt[i], optBookTotal);\r\n        }\r\n\r\n        /*\r\n            Now we decide which book has the least word count!\r\n        */\r\n        // initialize to the first one\r\n        let roundWinnerBook: string = newBooks[0]; \r\n        let roundWinnerCount: number = newCounts[0]; \r\n        for (let i=1; i < newBooks.length; i++) {\r\n            if (newCounts[i] < roundWinnerCount ) {\r\n                roundWinnerBook = newBooks[i];\r\n                roundWinnerCount = newCounts[i];\r\n            }\r\n        }\r\n        // record the winner\r\n        optBooks.push(roundWinnerBook);\r\n        optCounts.push(roundWinnerCount);\r\n        console.log(\"Round \", round, \"winner is \",roundWinnerBook, \" with count:\", roundWinnerCount);\r\n        \r\n        /* ------------------------------------------------------------\r\n\r\n            Now add the winner's UTA and UTW articles to the done list\r\n            these will not be done again in subsequent rounds\r\n\r\n        */\r\n        let bkid = books.bookIdByTitle(roundWinnerBook);\r\n        let dbkey = \"uta-\"+bkid;\r\n        let data = await dbsetup.bpstore.getItem(dbkey);\r\n        let dam = data.detail_article_map;\r\n        let articles = Object.keys(dam);\r\n\r\n        for (let j=0; j< articles.length; j++) {\r\n            // first check to see if this article is in the done list\r\n            // if so skip it\r\n            if ( doneArticleMap.has(articles[j]) ) { continue;}\r\n            let articleCount = dam[articles[j]].total;\r\n            // now add to map. dups expected\r\n            doneArticleMap.set(articles[j], articleCount);\r\n        }\r\n\r\n        // get the UTW articles and their counts\r\n        dbkey = \"utw-\"+bkid;\r\n        data = await dbsetup.bpstore.getItem(dbkey);\r\n        dam = data.detail_article_map;\r\n        articles = Object.keys(dam);\r\n\r\n        for (let j=0; j< articles.length; j++) {\r\n            // first check to see if this article is in the done list\r\n            // if so skip it\r\n            if ( doneArticleMap.has(articles[j]) ) { continue;}\r\n            let articleCount = dam[articles[j]].total;\r\n            // now add to map\r\n            doneArticleMap.set(articles[j], articleCount);\r\n        }\r\n    }\r\n    return (\r\n        <div>\r\n            <div>\r\n                <Typography >\r\n                Where the following books may be completed:\r\n                </Typography>\r\n                </div>\r\n                <div>\r\n                {booksDone.map(t => (\r\n                    <Typography key={t}>{t}</Typography>\r\n                ))}\r\n            </div>\r\n            <br/>\r\n            <br/>\r\n            <div>\r\n                <Typography >\r\n                The following books will be optimized:\r\n                </Typography>\r\n            </div>\r\n            <div>\r\n                {booksOpt.map(t => (\r\n                    <Typography key={t}>{t}</Typography>\r\n                ))}\r\n            </div>\r\n            <br/>\r\n            <br/>\r\n            <div>\r\n                <Typography >\r\n                Pre-Optimization Summary:\r\n                </Typography>\r\n                <div>\r\n                {bklist.map(t => (\r\n                    <Typography key={t}>\r\n                        Book {t} has word count total of {bookCountTotalsPreOpt.get(t)}. <br/>\r\n                        ... and a total word count of deduped articles (UTA, UTW) of {bookCountArticleTotalsPreOpt.get(t)}. <br/>\r\n                    </Typography>\r\n                ) )}\r\n                </div>\r\n            </div>\r\n            <br/>\r\n            <br/>\r\n            <div>\r\n                <Typography >\r\n                Book Package Flow Optimization: <br/>\r\n                (assumes constant velocity)\r\n                </Typography>\r\n                <div>\r\n                {optBooks.map( (t,i) => (\r\n                    <Typography key={t}>\r\n                        Book Package {t} has word count total of {optCounts[i]}. <br/>\r\n                    </Typography>\r\n                ) )}\r\n                </div>\r\n            </div>\r\n            <br/>\r\n            <br/>\r\n        </div>\r\n    )\r\n}\r\n\r\n\r\n\r\n\r\n/*   \r\n\r\n\r\n\r\n*/\r\n","import React from 'react';\nimport { withStyles, makeStyles, Theme, createStyles } from '@material-ui/core/styles';\nimport Paper from '@material-ui/core/Paper';\nimport Stepper from '@material-ui/core/Stepper';\nimport Step from '@material-ui/core/Step';\nimport StepLabel from '@material-ui/core/StepLabel';\nimport Button from '@material-ui/core/Button';\nimport Typography from '@material-ui/core/Typography';\n\nimport FormLabel from '@material-ui/core/FormLabel';\nimport FormControl from '@material-ui/core/FormControl';\nimport FormGroup from '@material-ui/core/FormGroup';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport FormHelperText from '@material-ui/core/FormHelperText';\nimport Checkbox, { CheckboxProps } from '@material-ui/core/Checkbox';\n\nimport Switch from '@material-ui/core/Switch';\n\nimport { green } from '@material-ui/core/colors';\nimport {BookPackageRollup} from 'book-package-rcl';\nimport * as books from '../src/core/books';\nimport * as opt from '../src/core/optimize';\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      width: '100%',\n    },\n    formControl: {\n      margin: theme.spacing(3),\n    },\n    button: {\n      marginRight: theme.spacing(1),\n    },\n    instructions: {\n      marginTop: theme.spacing(1),\n      marginBottom: theme.spacing(1),\n    },\n  }),\n);\n\nconst GreenCheckbox = withStyles({\n  root: {\n    color: green[400],\n    '&$checked': {\n      color: green[600],\n    },\n  },\n  checked: {},\n})((props: CheckboxProps) => <Checkbox color=\"default\" {...props} />);\n\nfunction joinBookIds(state: opt.bpStateIF ) {\n  const x = Object.keys(state);\n  let y: string[] = [];\n  for (let i=0; i<x.length; i++) {\n    if ( state[x[i]][0] ) {\n      y.push(books.bookIdByTitle(x[i]));\n    }\n  }\n  return y.join();\n}\n  \n    \nfunction getSteps() {\n  return ['Select Books', 'Book Package Results', 'Optimized Flow'];\n}\n\nfunction getStepContent(step: number) {\n  switch (step) {\n    case 0:\n      return 'Select books, then click Next to generate book package results';\n    case 1:\n      return 'Select any books completed, then click Next to optimize book package flow';\n    case 2:\n      return 'Finished';\n    default:\n      return 'Unknown step';\n  }\n}\n\n\n\nexport default function HorizontalLinearStepper() {\n  const classes = useStyles();\n  const [activeStep, setActiveStep] = React.useState(0);\n  const [skipped, setSkipped] = React.useState(new Set<number>());\n  const steps = getSteps();\n\n  const isStepOptional = (step: number) => {\n    return false;\n  };\n\n  const isStepSkipped = (step: number) => {\n    return skipped.has(step);\n  };\n\n  const handleNext = () => {\n    let newSkipped = skipped;\n    if (isStepSkipped(activeStep)) {\n      newSkipped = new Set(newSkipped.values());\n      newSkipped.delete(activeStep);\n    }\n\n    setActiveStep(prevActiveStep => prevActiveStep + 1);\n    setSkipped(newSkipped);\n  };\n\n  const handleBack = () => {\n    setActiveStep(prevActiveStep => prevActiveStep - 1);\n  };\n\n  const handleSkip = () => {\n    if (!isStepOptional(activeStep)) {\n      // You probably want to guard against something like this,\n      // it should never occur unless someone's actively trying to break something.\n      throw new Error(\"You can't skip a step that isn't optional.\");\n    }\n\n    setActiveStep(prevActiveStep => prevActiveStep + 1);\n    setSkipped(prevSkipped => {\n      const newSkipped = new Set(prevSkipped.values());\n      newSkipped.add(activeStep);\n      return newSkipped;\n    });\n  };\n\n  const handleReset = () => {\n    setActiveStep(0);\n  };\n\n  /* Switch stuff */\n  const [clearF, setClearF] = React.useState({\n    clearFlag: false,\n  });\n\n  const handleChangeClearFlag = (name: string) => (event: React.ChangeEvent<HTMLInputElement>) => {\n    setClearF({ ...clearF, [name]: event.target.checked });\n  };\n\n\n  /* Form/checkbox stuff */\n\n  // these are for the initial book seletion\n  const [state, setState] = React.useState({ ...books.titlesToBoolean() }); \n  const handleChange = (name: string) => (event: React.ChangeEvent<HTMLInputElement>) => {\n    let b: boolean[] = [];\n    b[0] = event.target.checked;\n    b[1] = false;\n    setState({ ...state, [name]: b });\n  };\n\n  const handleFinishedChange = (name: string) => (event: React.ChangeEvent<HTMLInputElement>) => {\n    let b: boolean[] = [];\n    b[0] = true;\n    b[1] = event.target.checked;\n    setState({ ...state, [name]: b });\n  };\n\n  const [_opt, setOpt] = React.useState(<div>Waiting-Optimize</div>);\n  React.useEffect( () => {\n    const fetchData = async () => {\n      let result;\n      try {\n        result = await opt.optimize(state);\n        setOpt(result);  \n      } catch (error) {\n        setOpt(\n          <div>\n            {error.message}\n          </div>\n        )\n        return;\n      }\n    };\n    if (activeStep !== 2) {return;}\n    fetchData();\n  }, [state,activeStep]); \n  // the parameter [] allows the effect to skip if value unchanged\n  // an empty [] will only update on mount of component\n  \n\n\n  return (\n    <div className={classes.root}>\n      <Stepper activeStep={activeStep}>\n        {steps.map((label, index) => {\n          const stepProps: { completed?: boolean } = {};\n          const labelProps: { optional?: React.ReactNode } = {};\n          if (isStepOptional(index)) {\n            labelProps.optional = <Typography variant=\"caption\">Optional</Typography>;\n          }\n          if (isStepSkipped(index)) {\n            stepProps.completed = false;\n          }\n          return (\n            <Step key={label} {...stepProps}>\n              <StepLabel {...labelProps}>{label}</StepLabel>\n            </Step>\n          );\n        })}\n      </Stepper>\n      <div>\n        {activeStep === steps.length ? (\n          <div>\n            <Typography className={classes.instructions}>\n              Optimized Book Package Flow\n            </Typography>\n            <Button onClick={handleReset} className={classes.button} variant=\"contained\" color=\"primary\" >\n              Reset\n            </Button>\n          </div>\n        ) : (\n          <div>\n            <FormGroup row>\n              <FormControlLabel\n                control={\n                  <Switch checked={clearF.clearFlag} onChange={handleChangeClearFlag('clearFlag')} value=\"clearFlag\" color=\"primary\" />\n                }\n                label=\"Refresh Book Package Data\"\n              />\n            </FormGroup>\n            <Typography className={classes.instructions}>{getStepContent(activeStep)}</Typography>\n            {(activeStep === 1 ) && (\n                <div>\n                  <FormControl required component=\"fieldset\" className={classes.formControl}>\n                  <FormLabel component=\"legend\">Select one or more</FormLabel>\n                  <FormGroup>\n                    <div>\n                      {Object.keys(state)\n                        .filter(function(book) {\n                          return state[book][0];\n                        }).map(t => (\n                          <FormControlLabel\n                          control={<GreenCheckbox checked={state[t][1]} onChange={handleFinishedChange(t)} value={t} key={t} />}\n                          label={t}\n                        />\n                      ))}\n                    </div>                \n                  </FormGroup>\n                  <FormHelperText />\n                  </FormControl>\n                </div>\n              )}\n            <div>\n              <Button disabled={activeStep === 0} onClick={handleBack} color=\"primary\" variant=\"contained\" className={classes.button}>\n                Back\n              </Button>\n              {isStepOptional(activeStep) && (\n                <Button\n                  variant=\"contained\"\n                  color=\"primary\"\n                  onClick={handleSkip}\n                  className={classes.button}\n                >\n                  Skip\n                </Button>\n              )}\n\n              {activeStep < 2 && (\n                <Button\n                  variant=\"contained\"\n                  color=\"primary\"\n                  onClick={handleNext}\n                  className={classes.button}\n                >\n                  Next\n                </Button>\n              )}\n\n              {activeStep === 2 && (\n                <Button onClick={handleReset} color=\"primary\" variant=\"contained\" className={classes.button}>\n                Reset\n                </Button>\n              )}\n\n\n\n              {(activeStep === 0) && (\n                <FormControl required component=\"fieldset\" className={classes.formControl}>\n                <FormLabel component=\"legend\">Select one or more</FormLabel>\n                <FormGroup>\n                  {books.bookDataTitles().map(t => \n                    <FormControlLabel\n                      control={<Checkbox checked={state[t][0]} onChange={handleChange(t)} value={t} />}\n                      label={t} key={t}\n                    />\n                  )}                \n                </FormGroup>\n                <FormHelperText />\n                </FormControl>\n              )}\n\n\n              {(activeStep === 1) && (\n                <div>\n                  <Paper>\n                    <BookPackageRollup bookId={joinBookIds(state)} chapter='' clearFlag={clearF.clearFlag} />\n                  </Paper>\n                </div>\n              )}\n\n\n              {(activeStep === 2) && (\n                <div>\n                  {_opt}\n                </div>\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}